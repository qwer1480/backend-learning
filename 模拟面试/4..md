1. ## java目前最新版本

**最新到23**

1. ## java锁机制 

第一类为隐式锁：synchronized同步关键字  java6引入了许多轻量级的锁改进synchronized

> 期的 synchronized 的实现就是基于上面所讲的原理，因为监视器锁(monitor)是依赖于底层的操作系统的 MutexLock 来实现的，而操作系统实现线程之间的切换时需要从用户态转换到核心态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高，这也是为什么早期的 synchronized 效率低的原因。

* 修饰对象   锁的是对象
* 修饰方法   锁的是this
* 静态方法   锁的是.class(类对象)

第二类为显式锁：java5引入的Lock（显式锁）以及对应的各种实现类

* 重入锁
* 读锁
* 写锁

![image-20241220135114290](https://shuaiyao85.oss-cn-qingdao.aliyuncs.com/img/202412201351524.png)

1. ## stampted锁是java几引入的

   java8引入stampted锁

2. ## 锁有什么作用

   锁是一种同步机制，控制多线程环境下资源的方法，确保数据的一致性和线程安全。

   * 互斥访问
   * 原子性操作的保证
   * 线程同步
   * 读写锁优化性能
   * 公平性和非公平性
   * 提高并发

3. ## 在写代码中什么时候用到了锁，在什么场景中用到了锁

4. ## 用过的集合框架

5. ## hashMap是否为线程安全，为什么经常用？

不安全，应为其性能好，在不需要线程安全的情况下，优先使用。保证线程安全的时候使用ConcurrentHashMap

1. ## hashmap底层的存储结构

2. ## 为什么用红黑树

   * 解决hsah冲突：`HashMap` 使用链表来解决哈希冲突，即当两个元素的哈希值相同时，它们会被存储在同一个链表中。然而，当链表变得太长时，查找性能会下降到 O(n)。红黑树的查找时间复杂度为 O(log n)，这在链表很长时可以显著提高性能。
   * 红黑树在插入和删除操作时也能保持较好的性能，这对于 `HashMap` 来说很重要，因为这些操作在哈希表中非常常见。
   * **空间效率**：红黑树相对于其他平衡树（如 AVL 树）来说，不需要额外的平衡因子存储，因此在空间上更为高效。
   * `HashMap` 在底层使用红黑树是为了在面对大量哈希冲突时，仍然能够保持较高的性能。这种设计使得 `HashMap` 在大多数情况下都能提供快速的访问速度

3. ## 动态代理哪几种  区别

JDK

GGLib

1. ## 设计模式  项目中用到了哪些

2. ## 项目中的策略模式用来干什么

3. ## 在学习中并发在那种场景用到过，且用到了什么技术

4. ## 广告业务中qps达到几万 几十万怎么维护后台服务

5. ## spring boot用的哪个版本（2.几？）   看过官方文档没有

6. ## springboot和spring的区别

7. ## bean的生命周期

8. ## bean的初始化的方法在哪个方法实现，最外层的方法是谁  想问refash方法

9. ## 给一个项目需求，说出dao service controller层  （没说分页）

10. ## 双亲委派机制

11. ## java8和java8之前jvm的区别

    方法区的区别：在java7之前是将方法区放在堆里面，一个叫永久代的地方。java8将方法区功能进行拆分，将一部分功能留在了堆里面一部分放在了元空间。字符串常量池留在了堆里面，运行时常量池放到了元空间里面。

12. ## mysql的索引

13. ## redis缓存击穿  缓存穿透  缓存雪崩的区别

14. ## redis持久化

15. ## redis分布式锁