### 1.arraryList将索引为3的元素删除 后面的元素将向前移动 低层是怎么实现移动的

**删除操作**：当你调用 `arrayList.remove(3)` 时，`ArrayList` 会执行如下操作：

- 从索引 `3` 位置开始，删除该元素。
- 随后，所有位于索引 `3` 之后的元素都会向前移动一位。具体来说，`index 4` 的元素会被移动到 `index 3`，`index 5` 的元素会被移动到 `index 4`，以此类推。

实际上 `ArrayList` 的实现中确实使用了 `System.arraycopy` 来实现元素的移动。在 `ArrayList` 中，删除一个元素时，它会通过 `System.arraycopy` 来高效地移动数组中的元素，从而填补空缺。

### 2. hashmap要不是要初始化时候指定容量

要 减少扩容判断

### 3. hashmap中的hash冲突

用拉链发解决   数组大于64、链表大于8转化为红黑树。长链表查询效率太低

#### **3.1 平均情况**

HashMap 的查找效率在平均情况下是 **O(1)**。

- **原因**：通过键计算哈希值，然后定位到数组中的某个桶，再在桶中搜索具体的键值对。
- 如果哈希函数均匀且冲突较少，每次查找的过程基本上只需计算一次哈希值和一次数组访问。

#### **3.2 最坏情况**

HashMap 的查找效率在最坏情况下是 **O(n)**。

- 原因

  当哈希冲突严重时，多个键被映射到同一个桶中，所有键值对会形成一个链表（或者树形结构）。

  - 如果是链表，则需要遍历链表，时间复杂度为 O(n)。
  - 如果是红黑树（Java 中 HashMap 的实现从 Java 8 开始，在桶的元素超过一定阈值后会转为红黑树），则查找效率为 O(log n)。

### 4. hashmap中的加载因子

###### 加载因子的影响：

1. **扩容时机**：加载因子控制了何时扩容。如果你设置了较小的加载因子（如 0.5），哈希表会在较少元素时进行扩容，可能会导致更多的内存分配和性能损失。而设置较大的加载因子（如 0.9）则可能导致哈希表的装载较满，从而增加冲突的概率，降低性能。
2. **性能权衡**：较低的加载因子会减少冲突（不同元素被哈希到相同桶中），但是可能会导致更多的内存使用，因为哈希表会更频繁地进行扩容。较高的加载因子则减少内存使用，但可能增加哈希冲突，从而影响查询性能。

###### `HashMap` 的构造函数

你可以通过 `HashMap` 的构造函数设置加载因子和初始容量：

- `HashMap(int initialCapacity)`：设置初始容量，默认加载因子为 0.75。
- `HashMap(int initialCapacity, float loadFactor)`：设置初始容量和加载因子。

### 5. JDK8默认的垃圾回收算法

新生代分为8：1：1，使用复制算法

### 6. mysql的锁

全局锁、表级锁、行级锁

表级锁：表锁、元数据锁、意向锁

行级锁：行锁、间隙锁、临建锁

### 7. 间隙锁防止什么问题

防止幻读

### 8. 间隙锁触发条件

* 范围查询

```sql
SELECT * FROM table WHERE id > 10 AND id < 20;
```

* select   ...  for update 

```mysql
SELECT * FROM table WHERE id >= 10 AND id <= 20 FOR UPDATE;
-- SELECT * FROM table：表示从名为 table 的表中选择所有列的数据。
-- WHERE id >= 10 AND id <= 20：这是查询的条件，表示筛选出 id 值在 10 到 20 范围内（包括 10 和 20）的所有行。
-- FOR UPDATE：表示对查询结果中的每一行都加 排他锁（exclusive lock），这样，其他事务不能对这些行进行修改，直到当前事务提交或回滚。排他锁会阻止其他事务对锁定的行进行任何更新或删除操作。
```

* SELECT ... LOCK IN SHARE MODE

`SELECT ... LOCK IN SHARE MODE` 是一种 **共享锁**，它在查询结果的行上加锁，但与 `FOR UPDATE` 的 **排他锁** 不同，**共享锁** 允许其他事务读取这些行，只要它们没有尝试修改这些行。

### 9. 意向锁作用

没加意向锁的时候在加表锁的时候需要判断有没有行锁，一行一行遍历。在加行锁的时候加上意向锁之后可以直接在后续加表锁的时候通过有没有意向锁来进行上锁  提高效率。

### 10. innodb

支持外键、事务、行锁

### 11. MyISAM

不支持外键  读比较高的时候选用

### 12. 当前端请求过大

* 使用nginx部署tomcat集群分布压力

* 也可以在前端存储请求，当后端可以的时候在发送给后端
