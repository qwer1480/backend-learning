# 1. 什么是类加载器

作用：类加载器在类加载的过程中，将字节码信息以流的方式加载到内存中。

* 启动类加载器：JDK9之后用java写。
* 拓展类加载器：加载jre/lib/ext目录之下的jar包
* 应用类加载器：加载classpath下的类
* 自定义加载器：子定义一个类加载器，继承classload类。重写findClass方法。

> findClass方法会调用defineClass方法，在堆上开辟空间

### **自定义类加载器**

![image-20241201124507775](JVM面试.assets/image-20241201124507775.png)

![image-20241201124544112](JVM面试.assets/image-20241201124544112.png)

# 2. 什么是双亲委派机制

![image-20241201124630210](JVM面试.assets/image-20241201124630210.png)

### 父类加载器

![image-20241201124656507](JVM面试.assets/image-20241201124656507.png)

### 双亲委派机制

回答：**双亲委派机制就是当一个类加载器在加载类的时候，会首先判断自己有没有加载过这个类，如果加载过就直接返回，没有加载过就会向上查找是否父类加载过，再由顶向下进行加载。**

![image-20241201125003579](JVM面试.assets/image-20241201125003579.png)

### 双亲委派的作用

* 保证类加载的安全性，防止恶意代码替换JDK的核心类，确保核心类的安全性。（案例：自己编写的java.lang.String想要覆盖）
* 避免重复加载，避免一个类被多次加载。

# 3. 如何打破双亲委派机制

>  不要进行向上查找的过程，就让这个加载器来加载，能加载就加载，不能加载就抛异常

![image-20241201125659909](JVM面试.assets/image-20241201125659909.png)

![image-20241201125710997](JVM面试.assets/image-20241201125710997.png)

**在源码的第一步就是判断这个类自己有没有加载过。**

![image-20241201130606701](JVM面试.assets/image-20241201130606701.png)

**实现双亲委派机制的代码**

![image-20241201130739468](JVM面试.assets/image-20241201130739468.png)

> 这里面需要注意findBootstrapClassOrNull（）方法是两个功能的合并，先查找加载过没有，没有就紧接着进行加载

**查找到最上头后还是没有人加载过，就执行下面这段findClass，每个类加载器加载不了就向子类抛异常，让子类去加载，最后由可以加载的类加载器进行finclass方法，里面会调用defineClass方法进行堆内存分配。**

![image-20241201131001847](JVM面试.assets/image-20241201131001847.png)

![image-20241201132529575](JVM面试.assets/image-20241201132529575.png)

**回答：实现自定义类加载器，重写loadClass方法，把原生的双亲委派机制的代码去掉**

# 4. 如何判断堆上的对象没有被引用

* 引用计数法
* 可达性分析

### 引用计数法

优点：简单，维护一个计数器

缺点：会导致循环引用，导致对象无法回收

![image-20241201133345982](JVM面试.assets/image-20241201133345982.png)

**由于无法回收，导致了内存泄漏**

### 可达性分析算法

![image-20241201133450493](JVM面试.assets/image-20241201133450493.png)

![image-20241201133544429](JVM面试.assets/image-20241201133544429.png)

# 5. jvm中有哪些引用类型

* 强
* 软
* 弱
* 虚

 ![image-20241201135227420](JVM面试.assets/image-20241201135227420.png)

# 6. TheadLocal中为啥使用弱引用

![image-20241201140450469](JVM面试.assets/image-20241201140450469.png)

![image-20241201140728694](JVM面试.assets/image-20241201140728694.png)

# 7. 垃圾回收算法

垃圾回收做两件事：

1.找到内存中存活的对象

2.释放不再存活的对象

* 标记清除
* 标记整理
* 复制
* 分代GC

![image-20250103184236392](https://shuaiyao85.oss-cn-qingdao.aliyuncs.com/img/202501031842500.png)

### Stop The World

![image-20250103184727646](https://shuaiyao85.oss-cn-qingdao.aliyuncs.com/img/202501031847706.png)

### 算法评价标准

* 吞吐量      100分钟 99分钟执行用户代码  1分钟GC
* 最大暂停时间   STW时间
* 堆使用效率   从堆的使用效率来说标记清楚算法要优于复制算法，应为复制算法只能利用一半的堆内存

### 标记清除算法

通过GC Root引用链打上存活对象的标记，然后清除。

![image-20241201141020155](JVM面试.assets/image-20241201141020155.png)

优点：简单，只需要维持一个标志位

缺点：

* 碎片化问题

![image-20250103185348348](https://shuaiyao85.oss-cn-qingdao.aliyuncs.com/img/202501031853425.png)

* 分配速度慢：维护一个空闲空间的链表

  ![image-20250103185533789](https://shuaiyao85.oss-cn-qingdao.aliyuncs.com/img/202501031855852.png)

### 复制算法

![image-20241201141400556](JVM面试.assets/image-20241201141400556.png)

![image-20241201141502278](JVM面试.assets/image-20241201141502278.png)

### 标记整理算法

为标记清除算法容易产生碎片的缺点进行优化

![image-20241201141600974](JVM面试.assets/image-20241201141600974.png)

![image-20241201141627497](JVM面试.assets/image-20241201141627497.png)

### 分代回收

**内存划分   新生代用复制算法实现，eden：s0：s1 为 8：1：1**

![image-20250103190136961](https://shuaiyao85.oss-cn-qingdao.aliyuncs.com/img/202501031901038.png)

![image-20250103190445193](https://shuaiyao85.oss-cn-qingdao.aliyuncs.com/img/202501031904286.png)

* 分代回收的流程

**分代回收的时候，创建出来的对象首先会放到Eden区，随着对象的创建，Eden区越来越满，这样的话爆满后就会出发年轻代的GC，称为Minor GC，通过可达性分析将Eden区和from区存活的对象放到To区，并且回收不存活的对象，此时交换form，to区且Eden区已经清空，然后新对象就可以放到Eden区了，而且每一次minorGC后，jvm会为每个存活的对象记录一个年龄。**

**当老年代放不进去的时候，会先进行年轻代的回收。因为有那么一种情况：就是当年轻代内存不够用的时候来了一个新对象，然后minorGC，但是minorGC后年轻代还是不够用，此时年轻代的对象都在GC Root上且年龄达不到放到老年代的要求，所以这个年龄很小的对象就会直接放到老年代，所以老年代不够用的时候，会先去minorGC一下，避免这种对象的跨年龄放入老年代。**

**当这种情况持续下去，老年代渐渐爆满，又来一个对象，先进去Eden区，Eden区满着呢，进行Minor GC，由于此时还和之前一样，所有对象还是都在GC Root链上且年龄达不到，所以还是回收不了，那这个新对象就会和刚才其他对象一样直接放入老年区。此时问题出现了，虽然我老年代容忍你跨年龄进来，但是我都满了你还在跨年龄进来太不礼貌了，所以此时进行一次minorGC，尽量让他先去年轻代带着。如果此时还是年轻代还是容不下它，而老年代也满了。就会触发Full GC对整个堆进行回收，此时STW就会比较长，如果Full GC依然无法回收老年代的对象，当再有是对象进入老年代的时候就会OOM**

![image-20241201142014980](JVM面试.assets/image-20241201142014980.png)

![image-20241201142026270](JVM面试.assets/image-20241201142026270.png)

# 8. 有哪些常用的垃圾回收器

![image-20241201142603705](JVM面试.assets/image-20241201142603705.png)

![image-20241201142617350](JVM面试.assets/image-20241201142617350.png)

### Serial+SerialOld

![image-20241201142716388](JVM面试.assets/image-20241201142716388.png)

### PS+PO

![image-20241201142807232](JVM面试.assets/image-20241201142807232.png)

### ParNew+CMS

![image-20241201142944230](JVM面试.assets/image-20241201142944230.png)

![image-20241201143021796](JVM面试.assets/image-20241201143021796.png)

![image-20241201143207544](JVM面试.assets/image-20241201143207544.png)

### G1

**参数：-XX:+UseG1GC**

![image-20250104142248490](https://shuaiyao85.oss-cn-qingdao.aliyuncs.com/img/202501041422663.png)

G1的内存结构并不是连续的，被划分了许多空间。G1不同于其他垃圾回收器，G1是对整个堆进行回收，采用复制算法对每个区域进行回收

G1垃圾回收有两种：

* 年轻代回收（Young GC）：主要针对年轻代区域的垃圾回收，包括Eden区和Survivor区。当所有Eden区使用率达到最大阀值（默认60%）或者G1计算出来的回收时间接近用户设定的最大暂停时间时，会触发一次Young GC，回收Eden区和Survivor区，复制移动到另外的Survivor幸存者（年龄+1）或Old老年代区（提前晋升的）
  
* 混合回收 （Mixed GC）：Mixed GC是G1垃圾回收器独有的，也称混合回收，针对年轻代和部分老年代区域的垃圾回收。当老年代的占有率达到阀值（默认45%）或年轻代被分配大对象时，会触发一次Mixed GC，回收所有年轻代和一部分老年代区（选取的策略是垃圾对象最多的老年代区域，确保释放更多内存空间，即回收价值高的），控制最大暂停时间。
  

![image-20241201143326054](JVM面试.assets/image-20241201143326054.png)

![image-20241201143556200](JVM面试.assets/image-20241201143556200.png)

# 9. 如何解决内存泄漏

![image-20241201143926331](JVM面试.assets/image-20241201143926331.png)

![image-20241201144023042](JVM面试.assets/image-20241201144023042.png)

**最主要的是前两步**

![image-20241201144231471](JVM面试.assets/image-20241201144231471.png)

![image-20241201144422758](JVM面试.assets/image-20241201144422758.png)

![image-20241201145022738](JVM面试.assets/image-20241201145022738.png)

# 10. 常见的JVM参数

* 最大堆内存
* 最大栈内存
* 最大元空间内存
* 日志参数
* 对内存快照
* 

![image-20241201150541389](JVM面试.assets/image-20241201150541389.png)

 ![image-20241201151215172](JVM面试.assets/image-20241201151215172.png)

![image-20241201151245295](JVM面试.assets/image-20241201151245295.png)

![image-20241201151329251](JVM面试.assets/image-20241201151329251.png)

# 11. 什么是JVM	

* 定义：JVM指 Java Virtual Machine.本质上是一个运行再计算机上的程序。
* 职责：运行字节码文件

* 作用：为了支持Java中的 Write Once Run Anywhere；编写一次，到处运行的跨平台特性。

* 功能：

![image-20241201152128474](JVM面试.assets/image-20241201152128474.png)

![image-20241201152307823](JVM面试.assets/image-20241201152307823.png)

回答：

* 1. JVM是java虚拟机，本质上是运行在计算机的一个程序，它的职责是运行字节码文件，作用是支持java的跨平台特性。

* 2. JVM的功能有三项：第一是解释并执行字节码文件，第二是管理内存中对象的分配完成自动的垃圾回收，第三是优化热点代码提高至执行效率

* 3. JVM的组成部分为：类加载子系统、运行时数据区、执行引擎、本地接口

* 4. 常用的JVM是Oracle提供的HotsPot虚拟机

  

# 12. 有没有了解过字节码文件的组成

![image-20241201152943614](JVM面试.assets/image-20241201152943614.png)

**魔数：ca fe ba be**

主版本号-44 = jdk版本

# 13. 运行时数据区

* 程序计数器：控制指令的运行，实现分支跳转；保存当前要执行的字节码的地址
* 栈：存放调用的方法的栈帧。
* 堆：存放对象、线程共享
* 方法区

![image-20241201154248479](JVM面试.assets/image-20241201154248479.png)

### 栈

![image-20241201154441683](JVM面试.assets/image-20241201154441683.png)

**每个线程都有自己的一块独立的占内存空间**

每个方法的调用会进行一次栈帧的压栈：栈帧的组成分为三部分：局部变量表、操作数栈、帧数据

![image-20241201154710779](JVM面试.assets/image-20241201154710779.png)

![image-20241201154726346](JVM面试.assets/image-20241201154726346.png)

![image-20241201154923915](JVM面试.assets/image-20241201154923915.png)

**局部变量表实际上是一个数组**

![image-20241201155046641](JVM面试.assets/image-20241201155046641.png)

### 堆

![image-20241201155155448](JVM面试.assets/image-20241201155155448.png)

### 方法区

![image-20241201155254717](JVM面试.assets/image-20241201155254717.png)

![image-20241201155326960](JVM面试.assets/image-20241201155326960.png)

![image-20241201155415617](JVM面试.assets/image-20241201155415617.png)

回答：运行时数据区是jvm所管理的内存区域，卡伊按照线程的共享分为两大类：

* 线程共享：堆和方法区
* 线程不共享：本地方法栈、虚拟机栈、程序计数器

# 14. 在哪些地方可以出现内存溢出

![image-20241201155814654](JVM面试.assets/image-20241201155814654.png)

### 堆溢出

![image-20241201155850755](JVM面试.assets/image-20241201155850755.png)

### 栈溢出

![image-20241201160014121](JVM面试.assets/image-20241201160014121.png)

### 方法区溢出

![image-20241201160157783](JVM面试.assets/image-20241201160157783.png)

### 直接内存

![image-20241201160349907](JVM面试.assets/image-20241201160349907.png)

# 15. JDK6-8的内存结构的不同

### 方法区的实现

![image-20241201160812014](JVM面试.assets/image-20241201160812014.png)

以前在堆里面找一块空间设置为永久代实现方法区，收到堆大小的限制，jdk8之后直接将直接内存里开一块空间使用元空间实现方法区，收到操作系统的内存大小的限制，格局一下子打开。这样可以提高内存上限

![image-20241201161052566](JVM面试.assets/image-20241201161052566.png)

### 字符串常量池的位置

![image-20241201161327307](JVM面试.assets/image-20241201161327307.png)

![image-20241201161549422](JVM面试.assets/image-20241201161549422.png)

### JDK6

![image-20241201161850167](JVM面试.assets/image-20241201161850167.png)

**方法区在堆中，存放类的元信息和字符串常量池和运行时常量池**

### JDK7

![image-20241201162014627](JVM面试.assets/image-20241201162014627.png)

**JDK7将字符串常量池从方法区中拿出来放在了堆里面，方法区里面存放类的元信息和运行时常量池**

### JDK8

![image-20241201162149493](JVM面试.assets/image-20241201162149493.png)

**JDK8将方法区移动到了系统空间的直接内存上，字符串常量池和JDK7一样在堆上，方法区里卖弄存放类的元信息和运行时常量池**

# 16. 类的生命周期

### 加载

![image-20241201162519141](JVM面试.assets/image-20241201162519141.png)

### 连接

1. 验证：做校验工作 例如魔数
2. 准备：为静态变量设置初值，如果是final就一步到位

![image-20241201162723836](JVM面试.assets/image-20241201162723836.png)

3. 解析：将符号引用转换为直接引用

   ![image-20241201162850279](JVM面试.assets/image-20241201162850279.png)

### 初始化

![image-20241201162908725](JVM面试.assets/image-20241201162908725.png)

为静态变量赋值，其实在连接阶段的准备阶段给静态变量赋了初值，现在是更改初值

![image-20241201163135913](JVM面试.assets/image-20241201163135913.png)

结果是2

如果打开new Demo，就会在执行clinit方法后去执行类的init方法，构造代码块是在创建对象的时候执行，所以此时结果是3

### 使用

...

### 卸载

![image-20241201163439693](JVM面试.assets/image-20241201163439693.png)

类的卸载很严格

### 总结

![image-20241201163539994](JVM面试.assets/image-20241201163539994.png)
