## 1. redis实现分布式锁

 redis通过使用set nx实现共享变量（也就是锁）的互斥访问，通过ex来设置过期时间，防止死锁。由于是两条命令，在执行nx后，可能由于各种原因（如redis宕机了）导致ex命令没有执行，为了保证原子性，将两条命令放在同一行使用。

在解锁的时候，持有锁的线程在锁的内部出现了阻塞，导致他的锁自动释放，这时其他线程，线程2来尝试获得锁，就拿到了这把锁，然后线程2在持有锁执行过程中，线程1反应过来，继续执行，而线程1执行过程中，走到了删除锁逻辑，此时就会把本应该属于线程2的锁进行删除，这就是误删别人锁的情况说明。**为了防止误删除锁，所以在设置锁的时候需要加入一个标识，例如可以是线程的id，这样的话当线程释放锁的时候，需要先去get这个锁的标识去判断是不是自己的锁，然后再del。**

这样的话又会遇到原子性问题：线程1现在持有锁之后，在执行业务逻辑过程中，他正准备删除锁，而且已经走到了条件判断的过程中，比如他已经拿到了当前这把锁确实是属于他自己的，正准备删除锁，但是此时他的锁到期了，那么此时线程2进来，但是线程1他会接着往后执行，当他卡顿结束后，他直接就会执行删除锁那行代码，相当于条件判断并没有起到作用。**为了保证这两条命令的原子性，我们可以使用lua脚本来保证，应为redis是单线程 ，当执行脚本的时候，其他任务都要阻塞，以保证安全。**

### 1.1 如何设置锁的过期时间

redisson中使用看门狗这个守护线程去不断更新锁的过期时间。

## 2. redis锁的续期机制

有两种方式吧，第一种是持有锁的线程主动续期，第二中是另外启动一个续期线程。第一种你适合短时间任务，第二个适合长时间任务，保证线程对业务的专注性。在redisson中，会有看门狗线程去续期，每隔10秒将锁的过期时间设置为30秒，当线程死掉之后，也就不再调用看门狗线程，锁过期自动释放。



## 3. redis的基本数据类型

string、list、hash、set、sortzet、bitMap、GEO、stream、HyperLonglong（大规模去重计数）

## 4. Redis的持久化机制

redis持久化机制有两种：RDB和AOF。

RDB是对内存数据的快照，在执行save命令的时候会进行rdb文件的生成，bgsave是异步fork出一个子进程，复制主进程的虚拟空间去异步的进行生成rdb文件，然后子进程将磁盘的旧RDB文件删除，将新的RDB文件保存在磁盘。也可以自己通过配置文件设置每隔多少秒进行rdb文件的保存。如果在两次保存rdb文件之间丢失了数据就真的丢了，fork出一个子进程也比较耗时

- RDB执行间隔时间长，两次RDB之间写入数据有丢失的风险
- fork子进程、压缩、写出RDB文件都比较耗时

AOF是对redis每一次命令进行保存，所以aof文件要比rdb文件大，它对数据的同步比较可靠，取决于它的刷盘策略，比如每秒刷盘，最多丢失一秒的数据。

## 5. redis过期键的删除策略

* 主动删除（惰性）：当访问到一个key时，判断他是否已经过期，如果过期则删除key并返回空结果。这种策略成本低，但是可能会留下很多僵尸key
* 被动删除（定期）：redis扫描key，抽取一些key进行检查，如果过期则删除，这种策略尽量删除大部分过期的key
* 内存淘汰：当redis的内存达到上限时会删除过期的key，这种策略作为内存压力过大的最后手段，保证redis稳定运行

redis以主动和被动删除为主，内存淘汰策略为辅。 

## 6. 
